1. Offline Signature-Based Threat Hunter
Instead of using a cloud AI to explain code, this project uses YARA Rules and Static Hash Matching to identify malware.

How it works: You download public malware signature databases (like the ClamAV database or Open-Source YARA rules).

The Tech: You use the yara-python library. The logic is entirely local: the code scans the file, finds a match in your local database, and alerts the user.

Why no API key? The "intelligence" is stored in local rule files (.yar), not a remote server.

2. Local Neural Network De-obfuscator
Build a tool that simplifies "messy" or obfuscated code (like Base64-packed scripts) using a locally hosted Small Language Model (SLM).

How it works: Use a model like Phi-3 or Llama-3 (8B) running on your server via Ollama.

The Tech: Your Python backend sends the code to a local Ollama instance (localhost:11434).

Why no API key? You are hosting the model yourself. You don't need to authenticate with Google or OpenAI because you are using your own computer's hardware (CPU/GPU) to do the thinking.

3. Heuristic Behavioral Sandbox (Static)
This project predicts what a program will do by calculating a "Suspect Score" based on library imports and system calls.

How it works: The program parses the code and looks for "dangerous" combinations, such as a script that uses both socket (networking) and os.walk (file searching).

The Tech: Use Python's ast (Abstract Syntax Trees) module to map the program's logic.

Why no API key? The analysis is purely mathematical and rule-based. It uses your own custom-written logic (e.g., if networking + file access, then risk = +40) to generate the threat report.